# ----------------------------------------------------------------------
# Script Purpose:
# This script processes the output files from DyNet for leaf microbiome networks 
# across multiple months. It performs two main tasks:
# 1. Reads and combines node attribute files to create a comprehensive node table 
#    that includes node identity, metadata, and the month they appear in.
# 2. Reads edge files to create a comprehensive edge table, classifying edges as 
#    positive, negative, or stable (linker) edges between months.
# The final node and edge tables are saved as CSV files for downstream network analysis 
# and visualization.
# ----------------------------------------------------------------------

# Set the working directory to where the node and edge files are stored
setwd('/Users/mahmoudi/Documents/temp_network/git/Dynamic_LeafMicrobiome/script_data/Fig4/Data/Step4_DyNetwork/node_edge_tables_FromDyNet')

# Load required library for data manipulation
library(tidyr)

# Print informative message for tracking progress
cat("Reading node attribute file...\n")

# Read additional metadata for nodes (e.g., taxonomic info)
nodeatributefile <- read.table("extra_info_for_node_table.txt", header = TRUE)

# List of node CSV files generated by DyNet for each month transition
nodelist = c("11-12node.csv","12-1node.csv","1-2node.csv","2-3node.csv")

# List of edge CSV files generated by DyNet for each month transition
edgelist = c("11-12edge.csv","12-1edge.csv","1-2edge.csv","2-3edge.csv")

# Names of months corresponding to the data files (used for labeling)
monthname <- c("nov","dec","jan","feb","mar")

cat("Processing nodes and creating node attribute table...\n")

# Initialize empty data frame to store processed node attributes
nodeatribute <- data.frame()  

# Loop over each node file
for (i in 1:4){
  cat("Processing node file:", nodelist[i], "...\n")
  
  # Read the node CSV file
  Node <- read.csv(file = nodelist[i])
  head(Node,2)  # Display first two rows for verification
  
  # Rename columns for clarity
  colnames(Node) <- c("SUID", "Firstnodefile", "Secondnodefile", "DnScoredegreeCorrected", 
                      "RewiringDnScore", "EdgeCount", "Name", "Selected", "SharedName")
  
  ### Process nodes that are present in the first month
  FirstMonth <- Node[Node$Firstnodefile=="true",]  
  FirstMonth1 <- FirstMonth[,c("Name", "SharedName")] 
  # Merge with metadata to get additional attributes
  FirstMonthB <- merge(FirstMonth1, nodeatributefile, by.x="Name", by.y="OtuName") 
  FirstMonthB$Month <- monthname[i]  # Assign month label
  # Create unique node identifier including month
  FirstMonthB1 <- data.frame(NodeName = paste(monthname[i], "_", FirstMonthB$Name, sep = ""), FirstMonthB) 
  
  ### Process nodes that are present in the second month
  SecondMonth <- Node[Node$Secondnodefile=="true",]  
  SecondMonth1 <- SecondMonth[,c("Name", "SharedName")] 
  SecondMonthB <- merge(SecondMonth1, nodeatributefile, by.x="Name", by.y="OtuName") 
  SecondMonthB$Month <- monthname[i+1]  # Assign month label
  SecondMonthB1 <- data.frame(NodeName = paste(monthname[i+1], "_", SecondMonthB$Name, sep = ""), SecondMonthB) 
  
  # Combine first and second month node information into the final attribute table
  nodeatribute <- rbind(nodeatribute, FirstMonthB1, SecondMonthB1)
}

# Remove duplicate nodes to get final node attribute table
finalnodeinfo = nodeatribute[!duplicated(nodeatribute$NodeName), ]

# Save node attribute table to CSV
write.csv(finalnodeinfo, "Fig4A_Network/nodeatributev.csv", quote = FALSE, row.names = FALSE)
cat("Node attribute table saved to Fig4A_Network/nodeatributev.csv\n")

##################################################################################################################

cat("Processing edges and creating edge table...\n")

# Initialize counter and empty data frame for edges
counter <- 0
finaledge <- data.frame()

# Loop over each edge file
for (i in 1:4){
  counter <- counter + 1
  cat("Processing edge file:", edgelist[i], "...\n")
  
  # Read corresponding node file for this month transition
  Node <- read.csv(file = nodelist[i])
  colnames(Node) <- c("SUID", "Firstnodefile", "Secondnodefile", "DnScoredegreeCorrected", 
                      "RewiringDnScore", "EdgeCount", "Name", "Selected", "SharedName")
  
  # Identify nodes present in both months (stable nodes)
  overlap <- Node[(Node$Secondnodefile=="true" & Node$Firstnodefile=="true"),]
  overlap1 <- overlap[,c("Name", "SharedName")]
  colnames(overlap1) <- c("Node1","Node2")
  overlap1$Node1 <- paste(monthname[i], overlap1$Node1, sep = "_")
  overlap1$Node2 <- paste(monthname[i+1], overlap1$Node2, sep = "_")
  overlap1$binarycorrelation <- "linkeredge"  # Mark as stable nodes
  overlap1$Correlation <- "no_info"
  ov <- overlap1
  ov$Stablenode <- "yes"
  
  # Read the edge CSV file for this month transition
  edge <- read.csv(file = edgelist[i])
  edge <- edge[,c(2,4,5,6,8,9,10,15)]
  colnames(edge) <- c("Corr_firstmonth","FirstedgefilePresentAbsence","FirstmonthPval",
                      "Corr_secondmonth","SecondedgefilePresentAbsence","DyNetPairwiseComparison",
                      "SecondmonthPval","sharedname")
  
  #### Process first month edges
  Firstmonthnedge <- edge[edge$FirstedgefilePresentAbsence=="true",]
  Firstmonthnedge1 <- separate(Firstmonthnedge, sharedname, c("Node1","Node2"), sep="(interacts with)", remove=FALSE)
  Firstmonthnedge2 <- Firstmonthnedge1[,c(1,9,10)]
  # Clean unwanted characters from node names
  Firstmonthnedge2[] <- lapply(Firstmonthnedge2, gsub, pattern='[( ]', replacement='') 
  Firstmonthnedge2[] <- lapply(Firstmonthnedge2, gsub, pattern='[) ]', replacement='')  
  Firstmonthnedge2$Node1 <- paste(monthname[i], Firstmonthnedge2$Node1, sep="_") 
  Firstmonthnedge2$Node2 <- paste(monthname[i], Firstmonthnedge2$Node2, sep="_")  
  
  # Classify correlations as positive or negative
  positivecor1 <- Firstmonthnedge2[Firstmonthnedge2$Corr_firstmonth>=0,]
  positivecor1$binarycorrelation <- "Positive"
  negativecore1 <- Firstmonthnedge2[Firstmonthnedge2$Corr_firstmonth<0,]
  negativecore1$binarycorrelation <- "Negative"
  FM <- rbind(positivecor1, negativecore1)
  colnames(FM) <- c("Correlation","Node1","Node2","binarycorrelation")
  FM1 <- FM[,c(2,3,4,1)]  # Reorder columns
  
  #### Process second month edges
  Secondmonthedge <- edge[edge$SecondedgefilePresentAbsence=="true",]
  Secondmonthedge1 <- separate(Secondmonthedge, sharedname, c("Node1","Node2"), sep="(interacts with)", remove=FALSE)
  Secondmonthedge2 <- Secondmonthedge1[,c(4,9,10)]
  # Clean unwanted characters from node names
  Secondmonthedge2[] <- lapply(Secondmonthedge2, gsub, pattern='[( ]', replacement='')
  Secondmonthedge2[] <- lapply(Secondmonthedge2, gsub, pattern='[) ]', replacement='')
  Secondmonthedge2$Node1 <- paste(monthname[i+1], Secondmonthedge2$Node1, sep="_")
  Secondmonthedge2$Node2 <- paste(monthname[i+1], Secondmonthedge2$Node2, sep="_")
  
  # Classify correlations as positive or negative
  positivecor2 <- Secondmonthedge2[Secondmonthedge2$Corr_secondmonth>=0,]
  positivecor2$binarycorrelation <- "Positive"
  negativecore2 <- Secondmonthedge2[Secondmonthedge2$Corr_secondmonth<0,]
  negativecore2$binarycorrelation <- "Negative"
  SM <- rbind(positivecor2, negativecore2)
  colnames(SM) <- c("Correlation","Node1","Node2","binarycorrelation")
  SM1 <- SM[,c(2,3,4,1)]  # Reorder columns
  
  # Combine stable edges and month-specific edges
  if (counter == 1){
    finaledge = rbind(finaledge, overlap1, FM1, SM1) 
  } else {
    finaledge = rbind(finaledge, overlap1, SM1) 
  }
}

# Save the final edge table to CSV
write.csv(finaledge, "Fig4A_Network/edge.csv", quote = FALSE, row.names = FALSE)
cat("Edge table saved to Fig4A_Network/edge.csv\n")
cat("Script finished successfully!\n")
